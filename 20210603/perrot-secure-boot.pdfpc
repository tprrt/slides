{"pdfpcFormat":1,"duration":20,"disableMarkdown":false,"noteFontSize":20,"pages":[{"idx":0,"label":"1","overlay":0,"note":"Welcome to this presentation.\n\nI'm Thomas and, today, I will speak about \"Secure boot in embedded Linux systems\".\n\nBut, first I'm going to introduce myself."},{"idx":1,"label":"2","overlay":0,"note":"I'm an embedded Linux engineer and a member of the Bootlin team, since a few months.\n\nMoreover, I also contribute to open-source projects.\n\nI'm living in Southern France, close to Toulouse."},{"idx":2,"label":"3","overlay":0,"note":"This presentation is divided in two parts:\n\n- The first part introduces secure boot,\n\n- As well as some notions about signature process.\n\n- I will also quickly speak about the impacts that it can bring.\n\nThe second part is an example of secure boot implementation on i.MX8 platform, which has the particularity of not requiring an initramfs.\n"},{"idx":4,"label":"5","overlay":0,"note":"Secure boot is a feature to verify the parts used to boot a system, including hardware and software.\n\n- To protect the system against hijacking\n\n- To protect users against:\n\t- tampering application\n\t- hardware fault\n\t- malware execution\n\nAnd finally, that allows the vendor to meet legal and commercial goals.\n"},{"idx":5,"label":"6","overlay":0,"note":"Another name for secure boot is \"Chain of trust\".\n\nBecause the main functionality of this feature is: At boot, each stage is able to verify the integrity of the next stage\nbefore its execution.\n\nFor it, each stage contains:\n\n- A signature created at build, that representing its integrity.\n\n- As well as the public key of the next stage, in order to perform the integrity checking.\n"},{"idx":6,"label":"7","overlay":0,"note":"Here, I'm introducing the notion of asymmetric signature, used in the chain of trust.\n\nAsymmetric signature is a couple of keys:\n\n- The public key that will be shared with recipients, to perform the data integrity checking.\n\n- And the private key that MUST be secret, it's used by the issuer to sign the shared data.\n\nThe data is hashed, then signed, to be shared with recipients, in addition to the public key.\n\nThen recipients are able to verify that the digest of the received data is correct.\n"},{"idx":7,"label":"8","overlay":0,"note":"Enable secure boot also involves to be able:\n\n- to manage keys, especially to be able to protect private keys.\n\n- to lock devices, during the manufacturing.\n\n- to build upgrade images including signatures and public keys.\n\nAnd to accept a raise of the boot time duration, because it adds some crypto operations to perform the checking.\n"},{"idx":8,"label":"9","overlay":0,"note":"Here, I will speak about an example of secure boot implementation, done for a target based on an i.MX8.\n"},{"idx":9,"label":"10","overlay":0,"note":"Secure boot can be implemented in several ways, depending on requirements.\n\nIn this example, there are four main parts, according to the boot process of the target:\n\n- To check the bootloader integrity, there is only one choice, that depends on the silicon vendor. Here, the feature is provided by NXP and called Advanced High Assurance Boot.\n\n- For kernel checking, we chose to use an U-boot feature named\n\"verified boot\".\n\n- And for the rootfs part we chose to use dm-verity because it's simple and it's able to use hardware offloading."},{"idx":10,"label":"11","overlay":0,"note":"The Advanced High Assurance Boot is more complex than the secure boot feature implemented for previous i.MX platforms.\n\nAs for the High Assurance Boot, of previous i.MX:\n\n- It uses asymetric keys and One-time programmable fuses, to store hashes of public keys.\n\n- All bootloader stages are packaged into a signed image throught Code Signing Tool.\n\n- And the secure status can be checked, from U-boot, with the hab_status command.\n\n- But it's boot flow is very different because it uses a Security Controller, and it's also able to start a specialized processor. Then it uses two containers."},{"idx":11,"label":"12","overlay":0,"note":"The image contains some binaries and it is divided in two main parts:\n\n- The first contains the binary of Security Controller Firmware and its signature, using NXP keys.\n\n- The second contains the SPL, the ARM Trusted Firmware, U-boot and the associated signature, using the OEM keys.\n\nAt boot, the System Controller Unit loads the Security Controller firmware then others bootloader stages, and\n\nAt each step the Security Controller validates the binary.\n\nWhen all binaries have been loaded and verified, they are executed, each at their turn.\n"},{"idx":12,"label":"13","overlay":0,"note":"The first step is to generate OEM keys.\n\nKeys are built with a script using a file that contains twice the passphrase and some parameters to configure the kind, the size of keys and the validity period.\n\nHere, we chose to use Elliptic algorithm because there is a limitation in silicon B0 of i.MX8.\n"},{"idx":13,"label":"14","overlay":0,"note":"In addition, it's necessary to generate the hash table, as well as their checksum that should be stored in the one-time programmable fuses.\n\nSo, there is another script for this purpose.\n\nIt's also possible to use the od command to check the hash table, in order to be sure that the values burnt will be correct."},{"idx":14,"label":"15","overlay":0,"note":"Once we have the keys, the hash table and the bootloader image, then it's necessary to write a little configutation file for Code Signing Tools, in order to build the signed image.\n\nHere, you can see an example.\n\nIt contains paths to the hash table, the public key, the bootloader binary that should be signed.\n\nBut also the offsets of the header signature block that depending on the target and that can be find from the datasheet.\n\n"},{"idx":15,"label":"16","overlay":0,"note":"\nThe signed bootloader will not be verified until the fuses \nare burnt.\n\nSo, here, it's an example of commands performed, from U-boot to burn and read them.\n"},{"idx":16,"label":"17","overlay":0,"note":"Before and after burning fuses, it's also possible, from U-boot, to check the secure boot status.\n\nIn case of issue, Security Controller return an event, that can be printed with the ahab_status command.\n\nThe event code returned corresponds to a kind of issue.\n\nIn addition, events are raised by container.\n\nFinally, if no event is raised then the target can be locked, thanks to the command ahab_close, that will burn an additional fuse to prevent unsigned bootloader execution.\n\n"},{"idx":17,"label":"18","overlay":0,"note":"Let's move on to the kernel signature.\n\nHere, we chose to use the U-boot feature called Verified boot.\n\nThis feature uses fitimage, that is a container and which content is described by an Image Source File.\n\nBasically, an Image Source File is a list of node representing each element of the fitimage.\n\nIt also uses asymetric keys, which public key will be stored in the U-boot binary; and the private key is used to sign the kernel image, at build.\n\nThe kernel image is built and signed is three steps through the dtc and mkimage command: the build of unsigned kernel image, the build of the signed kernel image, and finally the public key is injected in U-boot."},{"idx":18,"label":"19","overlay":0,"note":"Fitimage can contain some images and configurations.\n\nImages can be a kernel image, a device tree binary, a device tree overlay, boot script, and so on.\n\nA configuration is a combination of images.\n\nFrom this example, the fitimage contains only one kernel image, only one device tree binary and a boot script.\n\nAs well as, only one configuration using a combination of all the provided images.\n\nMoreover, images and configurations from the fitimage are hashed."},{"idx":19,"label":"20","overlay":0,"note":"There is two ways to sign a fitimage:\n\n- Either sign individually each image\n\n- Either sign each available configuration\n\nSign configurations allow to prevent mix-and-match attack.\n\nThis example, use the second way,  then a signature node has been added in the configuration node.\n\nIf we have chosen to sign individually each image then\na signature node would has been added in each node describing an image."},{"idx":20,"label":"21","overlay":0,"note":"The following commands allow to create a RSA key, as well as a public key and a certificate, that will be used to sign the kernel."},{"idx":21,"label":"22","overlay":0,"note":"Now, this is an example of commands that will be used to build and sign the kernel, and also to inject the public key into the U-boot binary.\n"},{"idx":22,"label":"23","overlay":0,"note":"Now, it remains to take care of rootfs integrity checking.\n\nThere are some available solutions, here we choose to use dm-verity.\n\nBasically, dm-verity is a virtual file system, using a hash tree, where each leaf is the hash of a block of file system.\nThen, dm-verity can be only used with block device, like squashfs, ubiblock, and so on.\nIn addition, it can be only used for read only devices.\n\nBy default, the hash tree is stored into a separated block device, called hash device. But it's also possible concatenate it with the data device.\n\nIn addition, it is possible to sign the root hash."},{"idx":23,"label":"24","overlay":0,"note":"Following, few commands to create a dm-verity device, then to check it and to open it.\n\nAs you can see it is very easy.\n\nHere, the hash tree is appened at the end of the data image, then we use the parameter \"--hash-offset\" to specify the end of the data.\n\nIn addition, the integrity of the device can be checked without knowing the root hash, but it is necessary to mount it.\n\nIt's not the case in this example,  but it's also possible to sign the root hash with a key that will be stored in the kernel keyring."},{"idx":24,"label":"25","overlay":0,"note":"Finally, one of the requirements didn't need an additional initramfs to prepare to real rootfs device.\n\nTo do that, we use dm-init, that allows from the kernel command line to early mount the dm-verity device that contains the root file system.\n\nIn addition, we chose to use a boot script stored in the fitimage and loaded by U-boot between the command that load the kernel and the one that boot it.\n\nAs this boot script is a part of the fitimage's configuration, then it's also signed.\n\nThis script is useful to store parameters that are required by dm-init to early mount the device mapper, like the root hash, the block size, and so on."},{"idx":25,"label":"26","overlay":0,"note":"Thank you for attending this presentation, I hope you liked it.\n\nDo you have any questions ?\n"}]}